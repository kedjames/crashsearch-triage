import os
import sys 
import hashlib
import subprocess
import csv
import json
import argparse
import pandas as pd
from datetime import datetime


class ReproductionOracle:
    
    def __init__(self):        
        self.bug_id = ''
        self.program = ''
        self.bug_type = ''   
        self.crash_path = '' 
        self.crash_input_file = '' 
        self.output_csv_file = ''
        self.binary_file = ''
        self.flags = ''
        self.prog_output = ''
        self.oracle_config = ''
        self.bt_full = ''
        self.bt_func = ''
        self.crash_inst = ''
        self.tmp_crash_details = ''
        self.signature_hash = ''
        self.my_sig = ''
        self.oracle = ''
        self.signal = False
        self.file_exist = False
        #self.writer = None
        self.crash_dict = dict()
        self.hash_set = set([])
        #self.csv_rows = []
        self.whitelist = ['libdislocator', '__GI_', '__assert_fail', 'libc_','__stack_','libc.so',
        'libasan.so','libc_start_main','_start']
        self.curr_dir = os.path.dirname(os.path.realpath(__file__))
 
    
    def check_white_list(self,line):
        for item in self.whitelist:
            if item in line:
                return True
        return False

    def get_path_to_line(self,directory, line):
        if "/" in line:
            line = os.path.basename(line)

        for path, subdirs, files in os.walk(directory):       
            for file_name in files:
                file_to_assess = os.path.join(path, file_name)
                #print(file_name)
                if os.path.isfile(file_to_assess): 
                    if file_name.strip() == line.strip().split(":")[0]: 
                        print(os.path.join(path, line))
                        return os.path.join(path, line)
        return None

    def get_line(self,file_name):
        # tmp
        if "./" in file_name: 
            file_name = file_name.replace("./","/")
        tmp_line = ''
        num = 0 
        if ":" not in file_name: return
        with open(file_name.split(":")[0].strip()) as fp: 
            if ".c"in file_name: 
                num = int(file_name.split(".c:")[1].strip())
            else: 
                num = int(file_name.split(".h:")[1].strip())
            count=1
            for line in fp: 
                if count == num:
                    #return line
                    if ";" in line:
                        if ";" in tmp_line:
                            return tmp_line+line
                        else:
                            return tmp_line+line
                    else:
                        tmp_line+=line
                        num = count+1
                        #print(num)
                count+=1

    
    def read_job_file(self,filename):
        with open(filename,'r') as json_file:
            cve_json_data = json.load(json_file) 
            # Bug id can be autogenerated aswell 
        self.bug_id = cve_json_data['bug_id'].strip()
        self.program = cve_json_data['program'].strip()
        self.bug_type = cve_json_data['bug_type'].strip()   
        self.crash_path = cve_json_data['crash_path'].strip() 
        self.crash_input_file = cve_json_data['crash_input_file'].strip() 
        self.output_csv_file = cve_json_data['output_csv_file'].strip() 
        self.binary_file = cve_json_data['binary_file'].strip()
        self.flags = cve_json_data['flags'].strip()
        if self.flags.lower() == 'n/a': self.flags = ''
        self.prog_output = cve_json_data['prog_output'].strip()
        if self.prog_output.lower() == 'n/a': self.prog_output = ''
        self.oracle_config = cve_json_data['oracle_config'].strip()
        if self.oracle_config.lower() == 'n/a': self.oracle_config = ''
        
        
    """
    save features/symptoms to a CSV file
    """
    def commit_to_csv(self,csv_rows):        
        self.file_exist = False
        if os.path.exists(self.output_csv_file):
            self.file_exist = True
            print("[*] {0} File Exists ".format(self.output_csv_file))
        with open(self.output_csv_file, "a") as out_file:
            writer = csv.writer(out_file)
            if not self.file_exist:
                writer_fields = ['id', 'bug_id', 'program', 'signal',
                'bug_type' ,'crash_func_full','crash_func',
                'back_trace_full','back_trace_func','crash_line']
                writer.writerow(writer_fields)
            writer.writerows(csv_rows) 
            
            
    def exec_commands(self, oracle='gdb'):        
        self.crash_dict = dict()
        self.hash_set = set([])
        self.signal = False
        csv_rows = []        
        cmd = '' 
        cmd_output = None
        stdout = None
        stderr = None
        cras_lst = []
        if self.oracle_config == 'no_preload':
            gdb_script = './gdb_bt_script_no_preload.gdb'
        else:
            gdb_script = './gdb_bt_script.gdb'
        self.oracle = oracle
        print("=====================================")
        print("[*]Processing Bug: [{0}]".format(self.bug_id)) 
        if oracle == 'gdb':
            print("[*]Oracle is: [GDB Debugger]")
        elif oracle == 'asan':
            print("[*]Oracle is: [Address Sanitizer]") 
        
        
        with open(self.crash_input_file) as crash_file:
            for filename in crash_file:
                filename = os.path.join(self.curr_dir,filename)
                filename = filename.strip()
                if oracle == 'gdb':                                        
                    if self.flags and self.prog_output:
                        cmd = 'gdb --batch --command='+gdb_script+' --args '+self.binary_file+' '+self.flags+' '+filename+' '+self.prog_output
                    elif self.flags:
                        cmd = 'gdb --batch --command='+gdb_script+' --args '+self.binary_file+' '+self.flags+' '+filename
                    elif self.prog_output:
                        cmd = 'gdb --batch --command='+gdb_script+' --args '+self.binary_file+' '+filename+' '+self.prog_output
                        #print("[*]Command: {0}".format(cmd))
                        #print(cmd)
                    else:
                        #print("Yeah")
                        cmd = 'gdb --batch --command='+gdb_script+' --args '+self.binary_file+' '+filename
                    #print("[*]Command: {0}".format(cmd))
                    #print("Command:[{0}]".format(cmd))
                    tmp_out = subprocess.Popen("rm *.tif ", shell=True,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                    cmd_output = subprocess.Popen("timeout 2 "+cmd, shell=True,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                    stdout,stderr = cmd_output.communicate()
                    stdout = stdout.splitlines()
                    self.parse_gdb_crash(stdout,stderr,filename)
                elif oracle == 'asan':
                    if self.flags and self.prog_output:
                        cmd = self.binary_file+' '+self.flags+' '+filename+' '+self.prog_output
                    elif self.flags:
                        cmd = self.binary_file+' '+self.flags+' '+filename
                    elif self.prog_output:
                        cmd = self.binary_file+' '+filename+' '+self.prog_output
                        #print(cmd)
                    else:
                        cmd = self.binary_file+' '+filename#+' ou.tif'
                    tmp_out = subprocess.Popen("rm *.tif", shell=True,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                    cmd_output = subprocess.Popen("timeout 1 "+cmd, shell=True,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                    stdout,stderr = cmd_output.communicate()
                    stdout = stdout.splitlines()
                    
                    #print("[*]Command: {0}".format(cmd))
                    if len(stdout) <10:
                        print("[*] {0} didnt crash".format(filename))
                        continue
                    else:
                        #print("[*]Command: {0}".format(stdout))
                        self.parse_asan_crash(stdout,stderr,filename)
                else:
                    print("[*] Invalid reproduction oracle {0}".format(self.oracle))
                    exit(1)
                if self.signature_hash not in self.hash_set and self.signal:                       
                    try:
                        print("=====================================")
                        print("           Summary")
                        print("=====================================")
                        print("[*]BT Full: {0}".format(self.bt_full))
                        print("[*]BT Func: {0}".format(self.bt_func))
                        crash_func_full = self.bt_full.split("<-")[1].strip() 
                        print("[*]Crash Func Full: {0}".format(crash_func_full))           
                        crash_func = self.bt_func.split("<-")[1].strip()
                        print("[*]Crash Funct: {0}".format(crash_func))
                        print("[*]Signal: {0}".format(self.my_sig))
                        print("[*]Crash Instruction: {0}".format(self.crash_inst))
                        cr_line = self.tmp_crash_details.split("<-")[1].strip()
                        print("[*]Crash Line 1: {0}".format(cr_line)) 
                        cr_line = cr_line.split("@")[1].strip() 
                        print("[*]Crash Line 2: {0}".format(cr_line)) 
                        
                        if oracle == 'gdb':
                            print("[*]Line Searched: {0}".format(os.path.join(self.crash_path,cr_line)))
                            path_to_file = self.get_path_to_line(self.crash_path, cr_line)
                            cr_line = self.get_line(path_to_file).strip()
                        elif oracle == 'asan':
                            print("[*]Line Searched: {0}".format(os.path.join(self.crash_path,cr_line)))
                            path_to_file = self.get_path_to_line(self.crash_path, cr_line)
                            cr_line = self.get_line(path_to_file).strip()
                        print("[*]Crash Line 3: {0}".format(cr_line)) 
                        print("------------------------------------")
                        
                    except Exception as e:
                        print("Error: {0}".format(e))
                        continue
                    row = [self.signature_hash, self.bug_id, self.program, self.my_sig, self.bug_type,
                           crash_func_full, crash_func, self.bt_full, self.bt_func, cr_line]
                    self.hash_set.add(self.signature_hash)
                    csv_rows.append(row) 
                if self.signature_hash in self.crash_dict and self.signal:
                    self.crash_dict[self.signature_hash].append(filename)
                elif self.signature_hash not in self.crash_dict and self.signal:
                    self.crash_dict[self.signature_hash] = [filename] 
        self.commit_to_csv(csv_rows) 
                
        
    def parse_gdb_crash(self,stdout,stderr,filename):
        self.crash_inst = ''
        self.bt_full = ''
        self.bt_func = ''
        self.tmp_crash_details = ''
        self.my_sig = ''
        self.signal = False
        my_ins = []
        crash_in_lib = True

        for line in stdout:
            line = line.decode("utf-8",errors='ignore')
            if not line: continue
            if "received signal" in line:
                self.signal = True
                self.my_sig =  line.split("signal",1)[1]
                self.my_sig =  self.my_sig.split(",",1)[0].strip()
                fl = self.crash_input_file.split("/")
                fl = fl[-1]   
                self.bug_type = "unknown"                   
            if self.signal:
                if "__GI_" in line or "__assert_fail" in line or "libc_" in line or "__stack_" in line \
                or "libdislocator" in line or "_IO_new_file" in line or "malloc.c" in line \
                or "_IO_new_fclose" in line:  
                    continue
                if "#" in line and "in" in line and "at" in line and ".c:"in line:
                    crash_in_lib = False
                    my_ins = line.split()
                    if "#" in str(my_ins[0]) and "0x" in str(my_ins[1]): 
                        self.bt_full+= "<-"+str(my_ins[3].strip())+"@"+os.path.basename(my_ins[-1])
                        self.bt_func+= "<-"+str(my_ins[3].strip())
                        self.tmp_crash_details+= "<-"+str(my_ins[3].strip())+"@"+my_ins[-1].strip()
                    elif "#" in str(my_ins[0]) and "0x" not in str(my_ins[1]):  
                        self.bt_full+= "<-"+str(my_ins[1].strip()+"@"+os.path.basename(my_ins[-1]))
                        self.bt_func+= "<-"+str(my_ins[1].strip())
                        self.tmp_crash_details+= "<-"+str(my_ins[1].strip()+"@"+my_ins[-1].strip())
                if "=>" in line:
                    self.crash_inst =  line.split(":")[1].strip() 
        with open(filename, 'rb') as poc:
            buf = poc.read()
            self.signature_hash = hashlib.sha256(buf).hexdigest() 
        #self.signature_hash = hashlib.sha256(self.bt_full.encode()).hexdigest()
        #print(self.signature_hash)


    def parse_asan_crash(self,stdout,stderr,filename):        
        self.crash_inst = ''
        self.bt_full = ''
        self.bt_func = ''
        self.tmp_crash_details = ''
        self.my_sig = ''
        self.signal = False
        my_ins = []
        crash_in_lib = True

        for line in stdout:
            line = line.decode("utf-8",errors='ignore')
            if not line: continue
            if "ERROR: AddressSanitizer:" in line:
                if "AddressSanitizer failed to allocate" in line:
                    self.bug_type = line.split("AddressSanitizer")[1].split("0x")[0].strip()
                elif "on address" in line and "AddressSanitizer" in line:
                    self.bug_type = line.split("AddressSanitizer:")[1].split("on")[0].strip()
                elif "detected" in line and "LeakSanitizer" in line and "on" in line:
                    self.bug_type = line.split("detected")[1].split("on")[0].strip()
                elif "detected" in line and "LeakSanitizer" in line:
                    self.bug_type = line.split("detected")[1].strip()
                else:
                    self.bug_type = 'unknown'
                sig_type = line.split("AddressSanitizer:")[1]
                sig_type = sig_type.split("on")[0].strip()                
                if "buffer" in sig_type or "SEGV" in sig_type or "use-after" in sig_type:
                    self.my_sig = 'SIGSEGV'
                elif "FPE" in sig_type:
                    self.my_sig = 'SIGFPE'
                else:
                    self.my_sig = 'Unknown'
                self.signal = True
                fl = self.crash_input_file.split("/")
                fl = fl[-1]
            if self.signal:
                if "#" in line and "0x" in line and ("libc.so" not in line.strip().lower()
                and "libasan.so" not in line.strip().lower() and "libc_start_main" \
                not in line.strip().lower() and "_start" not in line):
                    crash_in_lib = False
                    my_ins = line.split()
                    if "#" in str(my_ins[0]) and "0x" in str(my_ins[1]):
                        if "_start" in my_ins[3].strip() or "__libc_start_main" in my_ins[3].strip(): continue
                        self.bt_full+= "<-"+str(my_ins[3].strip())+"@"+os.path.basename(my_ins[-1])
                        self.bt_func+= "<-"+str(my_ins[3].strip())
                        self.tmp_crash_details+= "<-"+str(my_ins[3].strip())+"@"+my_ins[-1].strip()
                    elif "#" in str(my_ins[0]) and "0x" not in str(my_ins[1]):
                        self.bt_full+= "<-"+str(my_ins[1].strip()+"@"+os.path.basename(my_ins[-1]))
                        self.bt_func+= "<-"+str(my_ins[1].strip())
                        self.tmp_crash_details+= "<-"+str(my_ins[1].strip()+"@"+my_ins[-1].strip())
                if "=>" in line:
                    self.crash_inst =  line.split(":")[1].strip()
                else:
                    self.crash_inst = "N/A"
            if "can not provide additional" in line: break
            if "allocated by thread" in line: break 
        with open(filename, 'rb') as poc:
            buf = poc.read()
            self.signature_hash = hashlib.sha256(buf).hexdigest()
        #self.signature_hash = hashlib.sha256(self.bt_full.encode()).hexdigest()



if __name__ == '__main__':       
    parser = argparse.ArgumentParser(description= "Crash Reproduction Oracle for Extracting Symptoms")
    parser.add_argument("-g","--gdb",dest="gdb",default=None, help="Reproduce crash using GDB Debugger")
    parser.add_argument("-a","--asan",dest="asan",default=None,help="Reproduce crash using Address Sanitizer")
    args = parser.parse_args()
    rep_oracle = ReproductionOracle()    
    
    if len(sys.argv) == 1:
        parser.print_help()
    if args.gdb:
        rep_oracle.read_job_file(args.gdb)
        rep_oracle.exec_commands()
    elif args.asan:
        rep_oracle.read_job_file(args.asan)
        rep_oracle.exec_commands(oracle='asan')
